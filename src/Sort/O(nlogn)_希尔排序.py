# 希尔排序为插入排序的改良版
# 插入排序步长为1 每次和前面一个数比较

# 希尔排序的步长是从大到小调整的
#
# 6 5 3 1 8 7 2 4  初始步长为3
# —————
# 不考虑
# 从1开始,向前跳三位,来到6的位置跟6比较,比6小,交换位置
# 1 5 3 6 8 7 2 4
# 1来到了位置0,如果再往前跳3步就越界了, 所以处理下一个数字8
# 1 5 3 6 8 7 2 4
#   —————
# 8和5比,大于5,位置不变,直接停止比较的过程,进行下一个数字7
# 1 5 3 6 8 7 2 4
#     —————
# 1 5 3 6 8 7 2 4
#       —————
# 1 5 3 2 8 7 6 4
# —————
# 1 5 3 2 8 7 6 4
#         —————
# 1 5 3 2 4 7 6 8
#   —————
# 1 4 3 2 5 7 6 8
# 步长为3的调整结束, 开始步骤为2的调整, 然后步骤为1。
# 希尔排序最终都会以步长为1结束。

# 希尔排序成功的关键在于步长的选择,步长越优,时间复杂度越低。
# 最劣时间复杂度趋近与O(n^2)


class Solution(object):
    def shellSort(self, A):
        n = len(A)
        if n == 1:     # 1//2 = 0 
            return A

        gap = n // 2
        while gap > 0:
            i = gap
            while i < n:
                temp = A[i]
                j = i - gap
                while j >= 0 and A[j] > temp:
                    A[j + gap] = A[j]
                    j -= gap

                A[j + gap] = temp
                i += 1

            gap //= 2

        return A


if __name__ == '__main__':
    print(Solution().shellSort([54, 35, 48, 36, 27, 12, 44, 44, 8, 14, 26, 17, 28]))
